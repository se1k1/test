Sun. 11/22/15
-------------

BIG PICTURE (motion compensation):
	- we have T[][] and Ref[][]
	- divide T to macroBlks (DO NOT divide Ref[][] into macroBlks)
	- iterate through each macroBlks of T to find the best mach
	- once the best match is found, calculate motion vector
	( - then calculate the difference pixel value ) 
				<-- this is seperate

/*
 * - convert everything into gray scale image first - divide the original
* img to 16 x 16- you can just store it into the file
*/

BIG PICTURE (sequential search):
	- identify x,y
	- go to ref frm, and do the search
	- forloop of p
	- store difference in an array
	List<Integer> diffs = new LinkedList<Integer>();
	for(i = 1; i <= p; i++){

		diffs.add(compare T[x][y] with Ref[x-p][y-p] )// idx=0
		diffs.add(compare T[x][y] with Ref[x][y-p]) // idx=1
		diffs.add(compare T[x][y] with Ref[x+p][y-p]) // idx=2
		diffs.add(compare T[x][y] with Ref[x-p][y] )// idx=3
		diffs.add(compare T[x][y] with Ref[x][y] )// idx=4
		diffs.add(compare T[x][y] with Ref[x+p][y]) // idx=5
		diffs.add(compare T[x][y] with Ref[x-p][y+p])// idx=6
		diffs.add(compare T[x][y] with Ref[x][y+p] // idx=7
		diffs.add(compare T[x][y] with Ref[x+p][y+p])// idx=8
	}	

BIG PICTURE (logarithmic search):
  
  
  findMinDiff() will do:
	- per T[][] macroblock
	- go through each (2p + 1)^2 block in Ref[][]
		- find diff per searched block
		- instantiate refFrmBlk and add to diffs array


public float MAD( int[][] target, int[][] ref, int tx0, int ty0, 
			int rx0, int ry0,int macroBlkSizeIn )



- How do I test sequentialSearchMSD()?
	- create a dummy image 2d arrays, target[4][4] and ref[4][4]
		macroBlkSize = 2, 
	- assign simple pixel values
	- get the best matcing ref block and printout min, x, y
	
- combining the different search criteria and different diff. measure criteria  
===============
Motion Compensation - Algorithm
	•Given a sequence of frames (each have macroblocks) –
	•Encode first frame as IntraFrame
	•For each corresponding macroblock of next frame and current frame, find the difference.
		–If difference less than threshold => no motion, find residual error
		–If difference above threshold => may be motion, look in search range to find a matching block using matching criteria discussed above. Note motion vector and residual error
		–If difference (or total residual error) is too large for a majority of macroblocks, and/or after regular intervals encode the current frame as an Intraframe and proceed to previous step
================
Motion Compensation - Encoding
	•There are two things to encode here:
		–Motion Vector for every macroblock
		–Difference or residual for every macroblock
	•Motion vectors are typically encoded losslessly (similar to JPEG lossless mode)
	•The residuals e(x, y) are encoded lossy +lossless (DCT+Entropy) producing variable bit rate (VBR).
	•If smooth motion or no motion:
		–Motion prediction is good (residuals are small)
		–Entropy coded with few bits
	•If complex motion or change of scene:
		–Motion prediction is bad (residual are large)
		–Entropy coded with many bits	 
===================
Logarithmic Search Notes:
public Point FindElement(int[][] matrix, int number) {
    Point p = new Point(); // holds two integers and represents 
                           // a position in the matrix.
    int found = -1;
    for(int i = 0; i < N; i++) {
        found = binarySearch(matrix[i], number, 0, N);
        if(found != -1) { 
           p.setX(i); 
           p.setY(found); 
           return p; 
        }
    }
    return null;
}